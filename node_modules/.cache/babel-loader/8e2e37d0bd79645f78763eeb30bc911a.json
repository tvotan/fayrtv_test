{"ast":null,"code":"/*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */\nmodule.exports = magnetURIDecode;\nmodule.exports.decode = magnetURIDecode;\nmodule.exports.encode = magnetURIEncode;\n\nconst base32 = require('thirty-two');\n\nconst bep53Range = require('bep53-range');\n/**\n * Parse a magnet URI and return an object of keys/values\n *\n * @param  {string} uri\n * @return {Object} parsed uri\n */\n\n\nfunction magnetURIDecode(uri) {\n  const result = {}; // Support 'magnet:' and 'stream-magnet:' uris\n\n  const data = uri.split('magnet:?')[1];\n  const params = data && data.length >= 0 ? data.split('&') : [];\n  params.forEach(param => {\n    const keyval = param.split('='); // This keyval is invalid, skip it\n\n    if (keyval.length !== 2) return;\n    const key = keyval[0];\n    let val = keyval[1]; // Clean up torrent name\n\n    if (key === 'dn') val = decodeURIComponent(val).replace(/\\+/g, ' '); // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded\n    // URIs, so decode them\n\n    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n      val = decodeURIComponent(val);\n    } // Return keywords as an array\n\n\n    if (key === 'kt') val = decodeURIComponent(val).split('+'); // Cast file index (ix) to a number\n\n    if (key === 'ix') val = Number(val); // bep53\n\n    if (key === 'so') val = bep53Range.parse(decodeURIComponent(val).split(',')); // If there are repeated parameters, return an array of values\n\n    if (result[key]) {\n      if (!Array.isArray(result[key])) {\n        result[key] = [result[key]];\n      }\n\n      result[key].push(val);\n    } else {\n      result[key] = val;\n    }\n  });\n\n  if (result['x.pe']) {\n    // remove duplicates and convert to array\n    result['x.pe'] = Array.isArray(result['x.pe']) ? Array.from(new Set(result['x.pe'])) : [result['x.pe']];\n  } // Convenience properties for parity with `parse-torrent-file` module\n\n\n  let m;\n\n  if (result.xt) {\n    const xts = Array.isArray(result.xt) ? result.xt : [result.xt];\n    xts.forEach(xt => {\n      if (m = xt.match(/^urn:btih:(.{40})/)) {\n        result.infoHash = m[1].toLowerCase();\n      } else if (m = xt.match(/^urn:btih:(.{32})/)) {\n        const decodedStr = base32.decode(m[1]);\n        result.infoHash = Buffer.from(decodedStr, 'binary').toString('hex');\n      }\n    });\n  }\n\n  if (result.infoHash) result.infoHashBuffer = Buffer.from(result.infoHash, 'hex');\n  if (result.dn) result.name = result.dn;\n  if (result.kt) result.keywords = result.kt;\n  if (result['x.pe']) result.peerAddresses = result['x.pe'];\n  if (typeof result.tr === 'string') result.announce = [result.tr];else if (Array.isArray(result.tr)) result.announce = result.tr;else result.announce = [];\n  result.urlList = [];\n\n  if (typeof result.as === 'string' || Array.isArray(result.as)) {\n    result.urlList = result.urlList.concat(result.as);\n  }\n\n  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {\n    result.urlList = result.urlList.concat(result.ws);\n  } // remove duplicates by converting to Set and back\n\n\n  result.announce = Array.from(new Set(result.announce));\n  result.urlList = Array.from(new Set(result.urlList)); // convert x.pe into two level object\n\n  if (result['x.pe']) {\n    result.x = {\n      pe: result['x.pe']\n    };\n    delete result['x.pe'];\n  }\n\n  return result;\n}\n\nfunction magnetURIEncode(obj) {\n  obj = Object.assign({}, obj); // clone obj, so we can mutate it\n  // support using convenience names, in addition to spec names\n  // (example: `infoHash` for `xt`, `name` for `dn`)\n\n  if (obj.infoHashBuffer) obj.xt = `urn:btih:${obj.infoHashBuffer.toString('hex')}`;\n  if (obj.infoHash) obj.xt = `urn:btih:${obj.infoHash}`;\n  if (obj.name) obj.dn = obj.name;\n  if (obj.keywords) obj.kt = obj.keywords;\n  if (obj.announce) obj.tr = obj.announce;\n\n  if (obj.urlList) {\n    obj.ws = obj.urlList;\n    delete obj.as;\n  }\n\n  if (obj.peerAddresses) obj['x.pe'] = obj.peerAddresses; // translate x.pe for processing\n\n  if (obj.x && obj.x.pe) obj['x.pe'] = obj.x.pe;\n  let result = 'magnet:?';\n  Object.keys(obj).filter(key => key.length === 2 || key === 'x.pe').forEach((key, i) => {\n    const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];\n    values.forEach((val, j) => {\n      if ((i > 0 || j > 0) && (key !== 'kt' && key !== 'so' || j === 0)) result += '&';\n      if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+');\n\n      if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n        val = encodeURIComponent(val);\n      }\n\n      if (key === 'kt') val = encodeURIComponent(val);\n      if (key === 'so') return;\n      if (key === 'kt' && j > 0) result += `+${val}`;else result += `${key}=${val}`;\n    });\n    if (key === 'so') result += `${key}=${bep53Range.compose(values)}`;\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/tinvotan/Projects/fayrtv/fayr_test/watchparty/node_modules/magnet-uri/index.js"],"names":["module","exports","magnetURIDecode","decode","encode","magnetURIEncode","base32","require","bep53Range","uri","result","data","split","params","length","forEach","param","keyval","key","val","decodeURIComponent","replace","Number","parse","Array","isArray","push","from","Set","m","xt","xts","match","infoHash","toLowerCase","decodedStr","Buffer","toString","infoHashBuffer","dn","name","kt","keywords","peerAddresses","tr","announce","urlList","as","concat","ws","x","pe","obj","Object","assign","keys","filter","i","values","j","encodeURIComponent","compose"],"mappings":"AAAA;AACAA,MAAM,CAACC,OAAP,GAAiBC,eAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,MAAf,GAAwBD,eAAxB;AACAF,MAAM,CAACC,OAAP,CAAeG,MAAf,GAAwBC,eAAxB;;AAEA,MAAMC,MAAM,GAAGC,OAAO,CAAC,YAAD,CAAtB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,aAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASL,eAAT,CAA0BO,GAA1B,EAA+B;AAC7B,QAAMC,MAAM,GAAG,EAAf,CAD6B,CAG7B;;AACA,QAAMC,IAAI,GAAGF,GAAG,CAACG,KAAJ,CAAU,UAAV,EAAsB,CAAtB,CAAb;AAEA,QAAMC,MAAM,GAAIF,IAAI,IAAIA,IAAI,CAACG,MAAL,IAAe,CAAxB,GACXH,IAAI,CAACC,KAAL,CAAW,GAAX,CADW,GAEX,EAFJ;AAIAC,EAAAA,MAAM,CAACE,OAAP,CAAeC,KAAK,IAAI;AACtB,UAAMC,MAAM,GAAGD,KAAK,CAACJ,KAAN,CAAY,GAAZ,CAAf,CADsB,CAGtB;;AACA,QAAIK,MAAM,CAACH,MAAP,KAAkB,CAAtB,EAAyB;AAEzB,UAAMI,GAAG,GAAGD,MAAM,CAAC,CAAD,CAAlB;AACA,QAAIE,GAAG,GAAGF,MAAM,CAAC,CAAD,CAAhB,CAPsB,CAStB;;AACA,QAAIC,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGC,kBAAkB,CAACD,GAAD,CAAlB,CAAwBE,OAAxB,CAAgC,KAAhC,EAAuC,GAAvC,CAAN,CAVI,CAYtB;AACA;;AACA,QAAIH,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,IAAxB,IAAgCA,GAAG,KAAK,IAAxC,IAAgDA,GAAG,KAAK,IAA5D,EAAkE;AAChEC,MAAAA,GAAG,GAAGC,kBAAkB,CAACD,GAAD,CAAxB;AACD,KAhBqB,CAkBtB;;;AACA,QAAID,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGC,kBAAkB,CAACD,GAAD,CAAlB,CAAwBP,KAAxB,CAA8B,GAA9B,CAAN,CAnBI,CAqBtB;;AACA,QAAIM,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGG,MAAM,CAACH,GAAD,CAAZ,CAtBI,CAwBtB;;AACA,QAAID,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGX,UAAU,CAACe,KAAX,CAAiBH,kBAAkB,CAACD,GAAD,CAAlB,CAAwBP,KAAxB,CAA8B,GAA9B,CAAjB,CAAN,CAzBI,CA2BtB;;AACA,QAAIF,MAAM,CAACQ,GAAD,CAAV,EAAiB;AACf,UAAI,CAACM,KAAK,CAACC,OAAN,CAAcf,MAAM,CAACQ,GAAD,CAApB,CAAL,EAAiC;AAC/BR,QAAAA,MAAM,CAACQ,GAAD,CAAN,GAAc,CAACR,MAAM,CAACQ,GAAD,CAAP,CAAd;AACD;;AAEDR,MAAAA,MAAM,CAACQ,GAAD,CAAN,CAAYQ,IAAZ,CAAiBP,GAAjB;AACD,KAND,MAMO;AACLT,MAAAA,MAAM,CAACQ,GAAD,CAAN,GAAcC,GAAd;AACD;AACF,GArCD;;AAuCA,MAAIT,MAAM,CAAC,MAAD,CAAV,EAAoB;AAClB;AACAA,IAAAA,MAAM,CAAC,MAAD,CAAN,GAAiBc,KAAK,CAACC,OAAN,CAAcf,MAAM,CAAC,MAAD,CAApB,IACbc,KAAK,CAACG,IAAN,CAAW,IAAIC,GAAJ,CAAQlB,MAAM,CAAC,MAAD,CAAd,CAAX,CADa,GAEb,CAACA,MAAM,CAAC,MAAD,CAAP,CAFJ;AAGD,GAtD4B,CAwD7B;;;AACA,MAAImB,CAAJ;;AACA,MAAInB,MAAM,CAACoB,EAAX,EAAe;AACb,UAAMC,GAAG,GAAGP,KAAK,CAACC,OAAN,CAAcf,MAAM,CAACoB,EAArB,IAA2BpB,MAAM,CAACoB,EAAlC,GAAuC,CAACpB,MAAM,CAACoB,EAAR,CAAnD;AACAC,IAAAA,GAAG,CAAChB,OAAJ,CAAYe,EAAE,IAAI;AAChB,UAAKD,CAAC,GAAGC,EAAE,CAACE,KAAH,CAAS,mBAAT,CAAT,EAAyC;AACvCtB,QAAAA,MAAM,CAACuB,QAAP,GAAkBJ,CAAC,CAAC,CAAD,CAAD,CAAKK,WAAL,EAAlB;AACD,OAFD,MAEO,IAAKL,CAAC,GAAGC,EAAE,CAACE,KAAH,CAAS,mBAAT,CAAT,EAAyC;AAC9C,cAAMG,UAAU,GAAG7B,MAAM,CAACH,MAAP,CAAc0B,CAAC,CAAC,CAAD,CAAf,CAAnB;AACAnB,QAAAA,MAAM,CAACuB,QAAP,GAAkBG,MAAM,CAACT,IAAP,CAAYQ,UAAZ,EAAwB,QAAxB,EAAkCE,QAAlC,CAA2C,KAA3C,CAAlB;AACD;AACF,KAPD;AAQD;;AACD,MAAI3B,MAAM,CAACuB,QAAX,EAAqBvB,MAAM,CAAC4B,cAAP,GAAwBF,MAAM,CAACT,IAAP,CAAYjB,MAAM,CAACuB,QAAnB,EAA6B,KAA7B,CAAxB;AAErB,MAAIvB,MAAM,CAAC6B,EAAX,EAAe7B,MAAM,CAAC8B,IAAP,GAAc9B,MAAM,CAAC6B,EAArB;AACf,MAAI7B,MAAM,CAAC+B,EAAX,EAAe/B,MAAM,CAACgC,QAAP,GAAkBhC,MAAM,CAAC+B,EAAzB;AACf,MAAI/B,MAAM,CAAC,MAAD,CAAV,EAAoBA,MAAM,CAACiC,aAAP,GAAuBjC,MAAM,CAAC,MAAD,CAA7B;AAEpB,MAAI,OAAOA,MAAM,CAACkC,EAAd,KAAqB,QAAzB,EAAmClC,MAAM,CAACmC,QAAP,GAAkB,CAACnC,MAAM,CAACkC,EAAR,CAAlB,CAAnC,KACK,IAAIpB,KAAK,CAACC,OAAN,CAAcf,MAAM,CAACkC,EAArB,CAAJ,EAA8BlC,MAAM,CAACmC,QAAP,GAAkBnC,MAAM,CAACkC,EAAzB,CAA9B,KACAlC,MAAM,CAACmC,QAAP,GAAkB,EAAlB;AAELnC,EAAAA,MAAM,CAACoC,OAAP,GAAiB,EAAjB;;AACA,MAAI,OAAOpC,MAAM,CAACqC,EAAd,KAAqB,QAArB,IAAiCvB,KAAK,CAACC,OAAN,CAAcf,MAAM,CAACqC,EAArB,CAArC,EAA+D;AAC7DrC,IAAAA,MAAM,CAACoC,OAAP,GAAiBpC,MAAM,CAACoC,OAAP,CAAeE,MAAf,CAAsBtC,MAAM,CAACqC,EAA7B,CAAjB;AACD;;AACD,MAAI,OAAOrC,MAAM,CAACuC,EAAd,KAAqB,QAArB,IAAiCzB,KAAK,CAACC,OAAN,CAAcf,MAAM,CAACuC,EAArB,CAArC,EAA+D;AAC7DvC,IAAAA,MAAM,CAACoC,OAAP,GAAiBpC,MAAM,CAACoC,OAAP,CAAeE,MAAf,CAAsBtC,MAAM,CAACuC,EAA7B,CAAjB;AACD,GArF4B,CAuF7B;;;AACAvC,EAAAA,MAAM,CAACmC,QAAP,GAAkBrB,KAAK,CAACG,IAAN,CAAW,IAAIC,GAAJ,CAAQlB,MAAM,CAACmC,QAAf,CAAX,CAAlB;AACAnC,EAAAA,MAAM,CAACoC,OAAP,GAAiBtB,KAAK,CAACG,IAAN,CAAW,IAAIC,GAAJ,CAAQlB,MAAM,CAACoC,OAAf,CAAX,CAAjB,CAzF6B,CA2F7B;;AACA,MAAIpC,MAAM,CAAC,MAAD,CAAV,EAAoB;AAClBA,IAAAA,MAAM,CAACwC,CAAP,GAAW;AAAEC,MAAAA,EAAE,EAAEzC,MAAM,CAAC,MAAD;AAAZ,KAAX;AACA,WAAOA,MAAM,CAAC,MAAD,CAAb;AACD;;AAED,SAAOA,MAAP;AACD;;AAED,SAASL,eAAT,CAA0B+C,GAA1B,EAA+B;AAC7BA,EAAAA,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,GAAlB,CAAN,CAD6B,CACA;AAE7B;AACA;;AACA,MAAIA,GAAG,CAACd,cAAR,EAAwBc,GAAG,CAACtB,EAAJ,GAAU,YAAWsB,GAAG,CAACd,cAAJ,CAAmBD,QAAnB,CAA4B,KAA5B,CAAmC,EAAxD;AACxB,MAAIe,GAAG,CAACnB,QAAR,EAAkBmB,GAAG,CAACtB,EAAJ,GAAU,YAAWsB,GAAG,CAACnB,QAAS,EAAlC;AAClB,MAAImB,GAAG,CAACZ,IAAR,EAAcY,GAAG,CAACb,EAAJ,GAASa,GAAG,CAACZ,IAAb;AACd,MAAIY,GAAG,CAACV,QAAR,EAAkBU,GAAG,CAACX,EAAJ,GAASW,GAAG,CAACV,QAAb;AAClB,MAAIU,GAAG,CAACP,QAAR,EAAkBO,GAAG,CAACR,EAAJ,GAASQ,GAAG,CAACP,QAAb;;AAClB,MAAIO,GAAG,CAACN,OAAR,EAAiB;AACfM,IAAAA,GAAG,CAACH,EAAJ,GAASG,GAAG,CAACN,OAAb;AACA,WAAOM,GAAG,CAACL,EAAX;AACD;;AACD,MAAIK,GAAG,CAACT,aAAR,EAAuBS,GAAG,CAAC,MAAD,CAAH,GAAcA,GAAG,CAACT,aAAlB,CAdM,CAgB7B;;AACA,MAAIS,GAAG,CAACF,CAAJ,IAASE,GAAG,CAACF,CAAJ,CAAMC,EAAnB,EAAuBC,GAAG,CAAC,MAAD,CAAH,GAAcA,GAAG,CAACF,CAAJ,CAAMC,EAApB;AAEvB,MAAIzC,MAAM,GAAG,UAAb;AACA2C,EAAAA,MAAM,CAACE,IAAP,CAAYH,GAAZ,EACGI,MADH,CACUtC,GAAG,IAAIA,GAAG,CAACJ,MAAJ,KAAe,CAAf,IAAoBI,GAAG,KAAK,MAD7C,EAEGH,OAFH,CAEW,CAACG,GAAD,EAAMuC,CAAN,KAAY;AACnB,UAAMC,MAAM,GAAGlC,KAAK,CAACC,OAAN,CAAc2B,GAAG,CAAClC,GAAD,CAAjB,IAA0BkC,GAAG,CAAClC,GAAD,CAA7B,GAAqC,CAACkC,GAAG,CAAClC,GAAD,CAAJ,CAApD;AACAwC,IAAAA,MAAM,CAAC3C,OAAP,CAAe,CAACI,GAAD,EAAMwC,CAAN,KAAY;AACzB,UAAI,CAACF,CAAC,GAAG,CAAJ,IAASE,CAAC,GAAG,CAAd,MAAsBzC,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,IAAzB,IAAkCyC,CAAC,KAAK,CAA7D,CAAJ,EAAqEjD,MAAM,IAAI,GAAV;AAErE,UAAIQ,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGyC,kBAAkB,CAACzC,GAAD,CAAlB,CAAwBE,OAAxB,CAAgC,MAAhC,EAAwC,GAAxC,CAAN;;AAClB,UAAIH,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,IAAxB,IAAgCA,GAAG,KAAK,IAAxC,IAAgDA,GAAG,KAAK,IAA5D,EAAkE;AAChEC,QAAAA,GAAG,GAAGyC,kBAAkB,CAACzC,GAAD,CAAxB;AACD;;AACD,UAAID,GAAG,KAAK,IAAZ,EAAkBC,GAAG,GAAGyC,kBAAkB,CAACzC,GAAD,CAAxB;AAClB,UAAID,GAAG,KAAK,IAAZ,EAAkB;AAElB,UAAIA,GAAG,KAAK,IAAR,IAAgByC,CAAC,GAAG,CAAxB,EAA2BjD,MAAM,IAAK,IAAGS,GAAI,EAAlB,CAA3B,KACKT,MAAM,IAAK,GAAEQ,GAAI,IAAGC,GAAI,EAAxB;AACN,KAZD;AAaA,QAAID,GAAG,KAAK,IAAZ,EAAkBR,MAAM,IAAK,GAAEQ,GAAI,IAAGV,UAAU,CAACqD,OAAX,CAAmBH,MAAnB,CAA2B,EAA/C;AACnB,GAlBH;AAoBA,SAAOhD,MAAP;AACD","sourcesContent":["/*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */\nmodule.exports = magnetURIDecode\nmodule.exports.decode = magnetURIDecode\nmodule.exports.encode = magnetURIEncode\n\nconst base32 = require('thirty-two')\nconst bep53Range = require('bep53-range')\n\n/**\n * Parse a magnet URI and return an object of keys/values\n *\n * @param  {string} uri\n * @return {Object} parsed uri\n */\nfunction magnetURIDecode (uri) {\n  const result = {}\n\n  // Support 'magnet:' and 'stream-magnet:' uris\n  const data = uri.split('magnet:?')[1]\n\n  const params = (data && data.length >= 0)\n    ? data.split('&')\n    : []\n\n  params.forEach(param => {\n    const keyval = param.split('=')\n\n    // This keyval is invalid, skip it\n    if (keyval.length !== 2) return\n\n    const key = keyval[0]\n    let val = keyval[1]\n\n    // Clean up torrent name\n    if (key === 'dn') val = decodeURIComponent(val).replace(/\\+/g, ' ')\n\n    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded\n    // URIs, so decode them\n    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n      val = decodeURIComponent(val)\n    }\n\n    // Return keywords as an array\n    if (key === 'kt') val = decodeURIComponent(val).split('+')\n\n    // Cast file index (ix) to a number\n    if (key === 'ix') val = Number(val)\n\n    // bep53\n    if (key === 'so') val = bep53Range.parse(decodeURIComponent(val).split(','))\n\n    // If there are repeated parameters, return an array of values\n    if (result[key]) {\n      if (!Array.isArray(result[key])) {\n        result[key] = [result[key]]\n      }\n\n      result[key].push(val)\n    } else {\n      result[key] = val\n    }\n  })\n\n  if (result['x.pe']) {\n    // remove duplicates and convert to array\n    result['x.pe'] = Array.isArray(result['x.pe'])\n      ? Array.from(new Set(result['x.pe']))\n      : [result['x.pe']]\n  }\n\n  // Convenience properties for parity with `parse-torrent-file` module\n  let m\n  if (result.xt) {\n    const xts = Array.isArray(result.xt) ? result.xt : [result.xt]\n    xts.forEach(xt => {\n      if ((m = xt.match(/^urn:btih:(.{40})/))) {\n        result.infoHash = m[1].toLowerCase()\n      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {\n        const decodedStr = base32.decode(m[1])\n        result.infoHash = Buffer.from(decodedStr, 'binary').toString('hex')\n      }\n    })\n  }\n  if (result.infoHash) result.infoHashBuffer = Buffer.from(result.infoHash, 'hex')\n\n  if (result.dn) result.name = result.dn\n  if (result.kt) result.keywords = result.kt\n  if (result['x.pe']) result.peerAddresses = result['x.pe']\n\n  if (typeof result.tr === 'string') result.announce = [result.tr]\n  else if (Array.isArray(result.tr)) result.announce = result.tr\n  else result.announce = []\n\n  result.urlList = []\n  if (typeof result.as === 'string' || Array.isArray(result.as)) {\n    result.urlList = result.urlList.concat(result.as)\n  }\n  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {\n    result.urlList = result.urlList.concat(result.ws)\n  }\n\n  // remove duplicates by converting to Set and back\n  result.announce = Array.from(new Set(result.announce))\n  result.urlList = Array.from(new Set(result.urlList))\n\n  // convert x.pe into two level object\n  if (result['x.pe']) {\n    result.x = { pe: result['x.pe'] }\n    delete result['x.pe']\n  }\n\n  return result\n}\n\nfunction magnetURIEncode (obj) {\n  obj = Object.assign({}, obj) // clone obj, so we can mutate it\n\n  // support using convenience names, in addition to spec names\n  // (example: `infoHash` for `xt`, `name` for `dn`)\n  if (obj.infoHashBuffer) obj.xt = `urn:btih:${obj.infoHashBuffer.toString('hex')}`\n  if (obj.infoHash) obj.xt = `urn:btih:${obj.infoHash}`\n  if (obj.name) obj.dn = obj.name\n  if (obj.keywords) obj.kt = obj.keywords\n  if (obj.announce) obj.tr = obj.announce\n  if (obj.urlList) {\n    obj.ws = obj.urlList\n    delete obj.as\n  }\n  if (obj.peerAddresses) obj['x.pe'] = obj.peerAddresses\n\n  // translate x.pe for processing\n  if (obj.x && obj.x.pe) obj['x.pe'] = obj.x.pe\n\n  let result = 'magnet:?'\n  Object.keys(obj)\n    .filter(key => key.length === 2 || key === 'x.pe')\n    .forEach((key, i) => {\n      const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]]\n      values.forEach((val, j) => {\n        if ((i > 0 || j > 0) && ((key !== 'kt' && key !== 'so') || j === 0)) result += '&'\n\n        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')\n        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n          val = encodeURIComponent(val)\n        }\n        if (key === 'kt') val = encodeURIComponent(val)\n        if (key === 'so') return\n\n        if (key === 'kt' && j > 0) result += `+${val}`\n        else result += `${key}=${val}`\n      })\n      if (key === 'so') result += `${key}=${bep53Range.compose(values)}`\n    })\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}